\chapter{Badania eksperymentalne - wyniki i wnioski}
\label{ch:badania_eksperymentalne}

W niniejszym rozdziale prezentujemy wyniki oraz wnioski wynikające z przeprowadzonych badań eksperymentalnych. Zestawienie rezultatów eksperymentów zostało dokonane w sposób zrozumiały i klarowny, z odpowiednim wsparciem graficznym w postaci wykresów i tabel. Wnioski są bezpośrednio powiązane z wynikami badań oraz są zgodne z założonymi celami projektu.

\section{Metodologia badań}
\label{sec:metodologia_badan}

W tej sekcji szczegółowo omawiamy metody oraz podejście zastosowane podczas eksperymentów. Zostaną przedstawione narzędzia, parametry konfiguracyjne oraz procedura testowa, które razem tworzą ramy metodyczne naszego badania.

\subsection{Konfiguracja środowiska}
\label{subsec:konfiguracja_srodowiska}

Do eksperymentów wykorzystano następujące ustawienia konfiguracyjne środowiska:
\begin{verbatim}
    > ./main.py -m 'gpt-4-1106-preview' Vulnerable-Code-Snippets/
\end{verbatim}

\subsection{Procedura testowa}
\label{subsec:procedura_testowa}

Zaprojektowana procedura testowa miała na celu dokładną weryfikację funkcjonalności programu oraz ocenę jego skuteczności w wykrywaniu i naprawie podatności. Kryteria testowe zostały dobrane w sposób umożliwiający kompleksową analizę:
\begin{itemize}
    \item \textbf{Kryterium 1}: Dokładność identyfikacji podatności.
    \item \textbf{Kryterium 2}: Skuteczność proponowanych napraw.
    \item \textbf{Kryterium 3}: Efektywność czasowa analizy.
\end{itemize}

Procedura testowa przebiegała według następujących etapów:
\begin{enumerate}
    \item Selekcja i przygotowanie danych testowych.
    \item Analiza statyczna kodu z wykorzystaniem narzędzi AI.
    \item Przygotowanie środowiska testowego.
    \begin{enumerate}
        \item Instalacja zależności.
        \item Konfiguracja środowiska.
        \item Dopisanie podatnego kodu do serwera.
    \end{enumerate} 
    \item Przeprowadzenie testów funkcjonalnych oraz testów bezpieczeństwa.
    \item Analiza i interpretacja wyników.
\end{enumerate}

\subsection{Wyniki działania programu - przykład}
\label{subsec:wyniki_dzialania_programu}

Wyniki działania programu, prezentowane na konsoli oraz dokumentowane w plikach raportów, zapewniają bezpośredni wgląd w proces analizy kodu:
% Tutaj należy wstawić odpowiednią zawartość raportu w formacie Markdown, o ile jest dostępna

\markdownInput{../raports/Authentication_Bypass_20240120120144_raport.md} 




\section{Badania na zbiorze \textit{snoopysecurity/Vulnerable-Code-Snippets}}
\label{sec:badania_na_zbiorze_snoopysecurity}

Analiza zbioru \textit{snoopysecurity/Vulnerable-Code-Snippets} dostarczyła istotnych informacji na temat specyfiki podatności i skuteczności ich wykrywania przez system. Zbiór ten, zawierający 184 pliki źródłowe o łącznej liczbie 41831 tokenów, stanowił reprezentatywną próbkę dla naszych eksperymentów.

Eksperymenty przeprowadzono z wykorzystaniem poniższych parametrów:
\begin{verbatim}
    > ./main.py -m 'gpt-4-1106-preview' Vulnerable-Code-Snippets/
\end{verbatim}


\begin{verbatim}
2024-01-20 12:54:36: Welcome to gptester: the Static Code Analysis Agent
2024-01-20 12:54:36: I will now begin scanning: Vulnerable-Code-Snippets/, name: Vulnerable-Code-Snippets
2024-01-20 12:54:36: Beginning scan...
2024-01-20 12:54:36: Found 184 files to scan
2024-01-20 12:54:36: Tokens inside the directory: 41831
2024-01-20 12:54:36: Beginning code analysis...
2024-01-20 12:54:36: Using model: gpt-4-1106-preview
\end{verbatim}

\section{Przykład - Analiza błędnego kodu Vulnerable-Code-Snippets/Authentication\_Bypass}
\label{sec:analiza_blednego_kodu}
Pierwszą analizą, którą przeprowadzono na zbiorze \textit{snoopysecurity/Vulnerable-Code-Snippets}, była analiza błędnego kodu \textit{Authentication\_Bypass}. 

\subsection{Dane wejściowe}
\label{subsec:dane_wejsciowe_i_oczekiwane_wyniki}
W katalogu znajdował się jeden plik o nazwie \textit{CVE-2019-1937}, zawierający następujący kod źródłowy:
\newgeometry{top=1cm, left=2cm,right=2cm}
\begin{listing}
    \begin{minted}[fontsize=\scriptsize]{java}
     
     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) {
      (...)
            httpRequest = (HttpServletRequest)request;
            logger.debug("doFilter url: " + httpRequest.getRequestURL().toString());
            boolean isAuthenticated = this.authenticateUser(httpRequest);
              ^^^ 1.5) invokes authenticateUser() (function shown below)
              
            String samlLogoutRequest;
            if(!isAuthenticated) {
              ^^^ 1.6) if authenticateUser() returns false, we go into this branch
              
                samlLogoutRequest = request.getParameter("SAMLResponse");
                logger.info("samlResponse-->" + samlLogoutRequest);
                if(samlLogoutRequest != null) {
                    this.handleSAMLReponse(request, response, chain, samlLogoutRequest);
                } else {
                  ^^^ 1.7) if there is no SAMLResponse HTTP parameter, we go into this branch
                  
                    HttpSession session;
                    ProductAccess userBean;
                    String requestedUri;
                    if(this.isStarshipRequest(httpRequest)) {
                      ^^^ 1.8) checks if isStarshipRequest() returns true (function shown below)
                      
                        session = null != httpRequest.getSession(false)?httpRequest.getSession(false):httpRequest.getSession(true);
                        userBean = (ProductAccess)session.getAttribute("USER_IN_SESSION");
                        if(userBean == null) {
                          ^^^ 1.9) if there is no session server side for this request, follow into this branch...
                          
                            try {
                                userBean = new ProductAccess();
                                userBean.setCredentialId("");
                                userBean.setAdminPasswordReset(true);
                                userBean.setProductId("cloupia_service_portal");
                                userBean.setProfileId(0);
                                userBean.setRestKey(httpRequest.getHeader("X-Starship-Request-Key"));
                                userBean.setStarshipUserId(httpRequest.getHeader("X-Starship-UserName-Key"));
                                userBean.setLoginName("admin");
                                  ^^^ 1.10) and create a new session with the user as "admin"!
                                  
                                userBean.setStarshipSessionId(httpRequest.getHeader("X-Starship-UserSession-Key"));
                                requestedUri = httpRequest.getHeader("X-Starship-UserRoles-Key");
                                userBean.setAccessLevel(requestedUri);
                                if(requestedUri != null && requestedUri.equalsIgnoreCase("admin")) {
                                    AuthenticationManager authmgr = AuthenticationManager.getInstance();
                                    userBean.setAccessLevel("Admin");
                                    authmgr.evaluateAllowedOperations(userBean);
                                }

                                session.setAttribute("USER_IN_SESSION", userBean);
                                session.setAttribute("DEFAULT_URL", STARSHIP_DEFAULT_URL);
                                logger.info("userBean:" + userBean.getAccessLevel());
                            } catch (Exception var12) {
                                logger.info("username/password wrong for rest api access - " + var12.getMessage());
                            }

                            logger.info("userBean: " + userBean.getAccessLevel());
                        }

                        chain.doFilter(request, response);
\end{minted}
\caption{Kod źródłowy błędnego skrawka kodu \textit{CVE-2019-1937}}
\label{lst:code1}
\end{listing}

\restoregeometry

Należy zauważyć, że w kodzie znajdują się komentarze, które mogą być pomocne w analizie dla dużych modeli językowych. 
Aby potwierdzić tę hipotezę, przeprowadzono analizę kodu zarówno z jak i bez komentarzy oraz ze zmienioną nazwą pliku.

\subsection{Wynik}
\dots

\subsection{Przygotowanie środowiska testowego}

\subsection{Interpretacja wyników}
\label{subsec:interpretacja_wynikow}

Interpretacja wyników eksperymentów ujawniła istotne spostrzeżenia dotyczące możliwości wykorzystania modeli AI w celu poprawy bezpieczeństwa kodu. Analiza wykazała, że ...

% Tutaj należy dodać interpretację wyników w kontekście wykresów i tabel (jeśli takowe zostały przygotowane)

\section{Wnioski}
\label{sec:wnioski}

Na podstawie przeprowadzonych badań eksperymentalnych udało się zweryfikować założenia dotyczące efektywności wykorzystania modeli AI w procesie identyfikacji i naprawy podatności w kodzie źródłowym. Główne wnioski to:

% Tutaj należy wstawić wnioski z badania